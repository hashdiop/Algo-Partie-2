FUNCTION Search_And_Addition(tab1:ARRAY_OF INTEGER,tab2:ARRAY_OF INTEGER) : INTEGER
VAR
    i,j,k,resultat: INTEGER;
    liste_addition:ARRAY_OF INTEGER;
BEGIN
    resultat:=0
    FOR i FROM 0 TO tab1.length-1 STEP 1  DO //On fixe un element de la liste 1
            j := 0 ;
            WHILE (j < tab2.length) DO //Cet element sera compare aux elements de la liste 2
                IF (tab2[j] != tab1[i]) THEN //Si element non-presrnt dans la liste on va vers la liste_addition
                    FOR k FROM 0 TO liste_addition.length-1 STEP 1  DO //Chercher si cet elemtn n'est pas deja repertoriee dans la liste_addition
                        IF (tab2[j] !=liste_addition[k]) THEN
                            liste_addition.append(tab2[j]);
                        END_IF
                    END_FOR
                END_IF
                j := j+1 ; // mise Ã  jour de l'index
            END_WHILE
    END_FOR
    FOR k FROM 0 TO liste_addition.length-1 STEP 1  DO
        resultat+=liste_addition[k];
    END_FOR
   RETURN resultat
END





ALGORITHM PS_nvect 
VAR
    n,i,j :INTEGER;
    vecteur: ARRAY_OF FLOAT[2];
    vecteurs: ARRAY_OF vecteur;
BEGIN
// Parcourir l'ensemble des vecteurs
    FOR i FROM 0 TO n-1 STEP 1  DO
        FOR j FROM 0 TO n-1 STEP step  DO
            IF (i=j) THEN
                BREAK;
            ELSE
                // Tester l'orthogonalite
                IF (Produit_en_point(vecteurs[i],vecteurs[j])=0) THEN
                    Write("Les vecteurs",vecteurs[i],"et",vecteurs[j],"sont orthogonales");
                ELSE
                    Write("Les vecteurs",vecteurs[i],"et",vecteurs[j],"ne sont pas orthogonales")
                END_IF
            END_IF
        END_FOR
    END_FOR
    PROCEDURE Produit_en_point(ps)
    VAR
        v1 , v2 : ARRAY_OF FLOAT[2];
        ps : FLOAT :=0;
        i :INTEGER;
    BEGIN
        FOR i FROM 0 TO v1.length-1 STEP 1  DO
            ps+=v1[i]*v2[i];
        END_FOR
    END
END